{"title":"(3) [用Java实现MySQL] 会话状态与全局变量","uid":"1e574d405bfba9a072f8f42d60640eb9","slug":"(4)[用Java实现MySQL]  会话状态与全局变量","date":"2022-12-18T02:41:10.000Z","updated":"2022-12-20T02:52:28.943Z","comments":true,"path":"api/articles/(4)[用Java实现MySQL]  会话状态与全局变量.json","keywords":null,"cover":[],"content":"<h3 id=\"全局变量的维护\"><a href=\"#全局变量的维护\" class=\"headerlink\" title=\"全局变量的维护\"></a>全局变量的维护</h3><p>初创项目的时候，我利用Spring的Environment接口实现了全局维护和默认配置的基本模型。</p>\n<p>本章根据Request的特性封装成我们自己的MySqlSession<br>用SessionId 模拟真正开启的session窗口<br>要保证session数据和局部变量的隔离性<br>Session其实就是一个Map 关键是如何<strong>管理</strong></p>\n<h3 id=\"如何获取Session\"><a href=\"#如何获取Session\" class=\"headerlink\" title=\"如何获取Session?\"></a>如何获取Session?</h3><p>建立Session管理器，因为整个系统的连接处使用了http，借由Servlet的request我们可以直接把session区分开来，用servlet的SessionId来作为唯一标识<br>不考虑Session过期<br> 一个非常简单的会话管理器就有了</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 会话管理器\n *\n * @author gxz gongxuanzhang@foxmail.com\n **&#x2F;\npublic class SessionManager &#123;\n\n    private final static Map&lt;String, MySqlSession&gt; SESSION_BOX &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n\n    public static MySqlSession currentSession() &#123;\n        RequestAttributes requestAttributes &#x3D; RequestContextHolder.currentRequestAttributes();\n        return SESSION_BOX.computeIfAbsent(requestAttributes.getSessionId(), MySqlSession::new);\n    &#125;\n\n&#125;</code></pre>\n\n<h3 id=\"何时清理Session\"><a href=\"#何时清理Session\" class=\"headerlink\" title=\"何时清理Session?\"></a>何时清理Session?</h3><p>因为Session不过期的性质，如果我们开启一个窗口将会一直获取使用Session没有问题.<br>但是如果Session超过了最大数量，是需要拒绝新开启的Session的<br>所以直接从连接层提供。<br>但是这里Http的无状态的弊端就展现了，当退出会话的时候就 服务器是可能不知道的。<br>不过期 –&gt; 和无状态  两个特性产生了冲突<br>最终我还是决定把Session变成有过期时间的  默认十分钟<br>然后在SpringMVC的拦截器中加入了会话续期的内容</p>\n<p>一张图表示会话续期的过程<br><img src=\"/images/mysql/session.png\" alt=\"session\"  /></p>\n<p>SessionManager 就变成了</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SessionManager &#123;\n\n    private static TimedCache&lt;String, MySqlSession&gt; SESSION_BOX;\n\n\n    public static void init() &#123;\n        GlobalProperties global &#x3D; GlobalProperties.getInstance();\n        String sessionCount &#x3D; global.get(PropertiesConstant.MAX_SESSION_COUNT);\n        SESSION_BOX &#x3D; new TimedCache&lt;&gt;(Integer.parseInt(sessionCount));\n    &#125;\n\n\n    public static MySqlSession currentSession() throws SessionException &#123;\n        RequestAttributes requestAttributes &#x3D; RequestContextHolder.currentRequestAttributes();\n        MySqlSession mySqlSession &#x3D; SESSION_BOX.get(requestAttributes.getSessionId());\n        if (mySqlSession !&#x3D; null) &#123;\n            return mySqlSession;\n        &#125;\n        String sessionId &#x3D; requestAttributes.getSessionId();\n        GlobalProperties global &#x3D; GlobalProperties.getInstance();\n        mySqlSession &#x3D; new MySqlSession(sessionId);\n        if (!SESSION_BOX.put(sessionId, mySqlSession, Integer.parseInt(global.get(SESSION_DURATION)))) &#123;\n            throw new SessionException(&quot;会话创建失败&quot;);\n        &#125;\n        return mySqlSession;\n    &#125;\n\n\n&#125;</code></pre>\n","feature":true,"text":"全局变量的维护初创项目的时候，我利用Spring的Environment接口实现了全局维护和默认配置的基本模型。 本章根据Request的特性封装成我们自己的MySqlSession用SessionId 模拟真正开启的session窗口要保证session数据和局部变量的隔离性S...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"系列文章","slug":"系列文章","count":4,"path":"api/categories/系列文章.json"}],"tags":[{"name":"手写mysql","slug":"手写mysql","count":4,"path":"api/tags/手写mysql.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%B4%E6%8A%A4\"><span class=\"toc-text\">全局变量的维护</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Session\"><span class=\"toc-text\">如何获取Session?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%95%E6%97%B6%E6%B8%85%E7%90%86Session\"><span class=\"toc-text\">何时清理Session?</span></a></li></ol>","author":{"name":"龚宣璋","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"JAVA和DOTA都会点","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"(3) [用Java实现MySQL] 实现建表语句","uid":"9b2e5852df7ea6225604d1ed9bf3d9a9","slug":"(3)[用Java实现MySQL]  实现建表语句","date":"2022-12-14T03:41:10.000Z","updated":"2022-12-20T02:50:23.472Z","comments":true,"path":"api/articles/(3)[用Java实现MySQL]  实现建表语句.json","keywords":null,"cover":null,"text":"建表语句分析一个完整的建表语句如下 create table tablename( field_name coltype comment &#39;列注释&#39;, ... )comment &#x3D; &#39;表注释&#39;,engine&#x3D;&#39;存储引擎&...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"系列文章","slug":"系列文章","count":4,"path":"api/categories/系列文章.json"}],"tags":[{"name":"手写mysql","slug":"手写mysql","count":4,"path":"api/tags/手写mysql.json"}],"author":{"name":"龚宣璋","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"JAVA和DOTA都会点","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}