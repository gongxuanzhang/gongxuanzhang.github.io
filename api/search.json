[{"id":"e26b3cb6b6a5e36abaf5baf72f37c592","title":"从CREATE DATABASE开始","content":"从创建一个数据库开始表是属于数据库的，我们对数据的操作也是都是基于某个数据库。所以要有一个 创建数据库的功能，基于这个最简单的功能把整个流程搭建起来首先写两个接口，一个解析器  一个执行器\n&#x2F;**\n * 执行器，一般是解析Sql得到的\n *\n * @author gxz gongxuanzhang@foxmail.com\n * @see org.gongxuanzhang.mysql.service.parser.SqlParser\n **&#x2F;\npublic interface Executor &#123;\n\n    &#x2F;**\n     * 执行\n     *\n     * @return 返回执行结果\n     **&#x2F;\n    Result doExecute() ;\n&#125;\n&#x2F;**\n * Sql 语法分析器\n *\n * @author gxz gongxuanzhang@foxmail.com\n **&#x2F;\npublic interface SqlParser &#123;\n\n    &#x2F;**\n     * 解析sql成可执行对象\n     *\n     * @param sql 被解析的sql\n     * @return 返回可执行内容 或者直接报错\n     * @throws SqlParseException 解析过程中出现问题\n     **&#x2F;\n    Executor parse(String sql) throws SqlParseException;\n\n&#125;\n\n这两个接口作为我们整个流程的总接口使用\n流程简化用一张图表示\n\n\n剩下的就是开始编码。今天搭建了初版代码，大概900多行   整体流程已经搭建好了持续更新吧github: https://github.com/gongxuanzhang/java-mysql\n","slug":"搭建初版存储引擎","date":"2022-12-14T06:41:10.000Z","categories_index":"开发相关","tags_index":"用Java实现MySQL","author_index":"龚宣璋"},{"id":"c44b749e59e22c5d8a70f42e6709d7f0","title":"初创项目","content":"整体架构整体架构是根据MySQL的架构实现，既然要实现MySQL那就尽可能的还原，虽然不能百分百做到，还是尽自己所能\n经典的MySQL架构图\n\n\n\n\n\n\n\n\n\n\nMySQL架构主要分为三个部分  连接层，服务层，存储层其中学习的主要部分在存储层。但是我是为了实现，所以要考虑所有内容\n初版思路连接层\n\n\n\n\n\n\n\n\n连接层使用Spring Web 直接通过http传入SQL 暂时不考虑连接池，用户权限等多因素\n服务层\n\n\n\n\n\n\n\n\n服务层完美的解决方案应该是用《编译原理》的词法解析，语法解析，优化器，到执行引擎初版先通过简单的字符串解析。也不实现太多功能  比如连表查询 之后一点点增加\n存储层\n\n\n\n\n\n\n\n\n存储层理论上是最复杂的，这里直接上InnoDB的思路实现，细节需要一点一点完善从一条insert语句开始 一点点实现\n为什么用SpringBoot其实最开始我想不用Spring。直接用完全JDK实现.但是连接层最轻松的实现就是SpringWeb了，既然用了就直接用一些Spring的一些工具类,毕竟目的是学习MySQL，其他技术只是为了方便目的而已\n基础系统功能环境变量功能MySQL有全局变量，会话变量。 变量分为只读和普通，有类型。变量可以读取配置文件，也可以启动参数直接读。既然是SpringBoot项目  不如借用一下 Spring的Environment\u0000 一用。创建全局配置类GlobalProperties\u0000，注入Environment,同时自己维护一个变量表，一个只读的key表。如果用户修改了变量表，在只读key中就直接报错，不在的话只需要修改自己维护的表即可。不需要修改Spring上下文。查询的时候先查自己维护的表，如果没有再查Spring。鉴于篇幅所限，系列文章只聊思路不贴代码，如果读者直接去下载源码进行阅读。\n","slug":"初创项目","date":"2022-12-14T03:41:10.000Z","categories_index":"开发相关","tags_index":"用Java实现MySQL","author_index":"龚宣璋"},{"id":"2b723abdda595c7271b214bbf961de56","title":"hexo Aurora 删除评论侧边栏","content":"hexo Aurora 去掉评论区问题：评论侧边栏今天刚搭建了博客，用了hexo Aurora主题\n整体主题挺满意的，但是有两个地方非常难受。\n\n\n\n\n在配置文件中设置了不启用之后变成了这样\n\n\n\n\n仅仅是不请求接口了，但是侧边栏仍然存在，看了文档和github，好多人都有这个问题。下面来解决这个问题\n解决首先”最近评论”这几个字一定有几个地方存在，那我们搜索一下包含最近评论的文件，看看能不能找到端倪\n直接控制台搜索\ngrep -i -r &#39;最近评论&#39; .\n\n\n好的 我们发现了一个js文件.编辑他。\n这是个打包后的js文件，方法名都是没有意义的，都是编号。\n没关系我们格式化之后直接定位具体内容\n&quot;9abb&quot;: function (e) &#123;\n        e.exports &#x3D; JSON.parse(&#39;&#123;&quot;menu&quot;:&#123;&quot;home&quot;:&quot;首页&quot;,&quot;about&quot;:&quot;关于&quot;,&quot;archives&quot;:&quot;归档&quot;,&quot;categories&quot;:&quot;分类&quot;,&quot;tags&quot;:&quot;标签&quot;,&quot;post&quot;:&quot;文章&quot;,&quot;message-board&quot;:&quot;留言板&quot;,&quot;search&quot;:&quot;搜索结果&quot;,&quot;not-found&quot;:&quot;无法找到页面&quot;&#125;,&quot;home&quot;:&#123;&quot;recommended&quot;:&quot;推荐文章&quot;&#125;,&quot;titles&quot;:&#123;&quot;articles&quot;:&quot;文章列表&quot;,&quot;about&quot;:&quot;关于我&quot;,&quot;category_list&quot;:&quot;分类目录&quot;,&quot;tag_list&quot;:&quot;标签目录&quot;,&quot;toc&quot;:&quot;文章目录&quot;,&quot;comment&quot;:&quot;评论区&quot;,&quot;recent_comment&quot;:&quot;最近评论&quot;&#125;,&quot;settings&quot;:&#123;&quot;months&quot;:[&quot;一月&quot;,&quot;二月&quot;,&quot;三月&quot;,&quot;四月&quot;,&quot;五月&quot;,&quot;六月&quot;,&quot;七月&quot;,&quot;八月&quot;,&quot;九月&quot;,&quot;十月&quot;,&quot;十一月&quot;,&quot;十二月&quot;],&quot;articles&quot;:&quot;文章&quot;,&quot;categories&quot;:&quot;分类&quot;,&quot;tags&quot;:&quot;标签&quot;,&quot;words&quot;:&quot;文字&quot;,&quot;visitor_count&quot;:&quot;总共访客数&quot;,&quot;visit_count&quot;:&quot;总共访问数&quot;,&quot;button-all&quot;:&quot;全部&quot;,&quot;paginator&quot;:&#123;&quot;newer&quot;:&quot;新的&quot;,&quot;older&quot;:&quot;以往&quot;,&quot;prev&quot;:&quot;上一篇更回味&quot;,&quot;next&quot;:&quot;下一篇更精彩&quot;&#125;,&quot;more-tags&quot;:&quot;查看更多&quot;,&quot;admin-user&quot;:&quot;博主&quot;,&quot;shared-on&quot;:&quot;发布于&quot;,&quot;recently-search&quot;:&quot;最近搜索&quot;,&quot;search-result&quot;:&quot;一共找到 [total] 个结果&quot;,&quot;no-recent-search&quot;:&quot;没有最近搜索记录。&quot;,&quot;no-search-result&quot;:&quot;没有找到任何记录。&quot;,&quot;cmd-to-select&quot;:&quot;查看&quot;,&quot;cmd-to-navigate&quot;:&quot;选择&quot;,&quot;cmd-to-close&quot;:&quot;关闭&quot;,&quot;searched-by&quot;:&quot;搜索引擎&quot;,&quot;tips-back-to-top&quot;:&quot;返回顶部&quot;,&quot;tips-open-menu&quot;:&quot;打开菜单&quot;,&quot;tips-back-to-home&quot;:&quot;返回首页&quot;,&quot;tips-open-search&quot;:&quot;打开搜索&quot;,&quot;default-category&quot;:&quot;文章&quot;,&quot;default-tag&quot;:&quot;未分类&quot;,&quot;empty-tag&quot;:&quot;目前没有标签&quot;,&quot;pinned&quot;:&quot;置顶&quot;,&quot;featured&quot;:&quot;推荐&quot;&#125;&#125;&#39;)\n    &#125;\n\n好消息是这个最近评论只有这一个地方出现过。\n坏消息是这个json之后做了什么也不得而知。\n先尝试第一步，修改一下文本内容看看生不生效\n\n\n\n\n重启一下看看效果\n\n\n\n\n\n\n\n\n\n\n\n很好，已经修改成功了。下一步就是把他干掉\n这个评论内容在json中的key是recent_comment\n全局搜索哪里用到了这个字段\n\n发现了这么一段代码，方法名是ie.继续找哪里用到了ie\n\n\n直接注掉这行代码。\n\n\n重启之后成功删除\n\n\n\n","slug":"aurora删除评论侧边栏","date":"2022-11-09T03:41:10.000Z","categories_index":"开发相关","tags_index":"一些黑科技","author_index":"龚宣璋"},{"id":"bb505a75d0ca128654929c76eb9bc898","title":"Logback和SpringCloud配置中心取值UNDEFINED问题","content":"问题描述在使用Logback时，如果需要动态输出路径，可以在logback-spring.xml中配置和spirng相关内容举个伪代码例子\n&lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;outFilePath&quot; source&#x3D;&quot;filePath&quot;&#x2F;&gt;\n&lt;appender name&#x3D;&quot;info&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;\n  &lt;FileNamePattern&gt;$&#123;OPEN_FILE_PATH&#125;&#x2F;info&#x2F;%d&#123;yyyy-MM-dd&#125;&#x2F;$&#123;applicationName&#125;-%i.log&lt;&#x2F;FileNamePattern&gt;\n&lt;&#x2F;appender&gt;\n\n例子中的输入路径是动态配置的。可以直接在application.yml中进行配置。但如果我们是Spring Cloud环境中,而且filePath配置在配置中心中，Spring cloud会加载两次容器，第一次是bootStrap容器，用来加载配置中心的配置，第二次是真正我们的Spring Bean容器所以当文件路径在配置中心时，会出现 “filePath_IS_UNDEFINED”的文件夹。\n解决目标\n让日志不出现XXX_IS_UNDEFINED文件夹\n如果配置中心中没有配置，给默认路径让日志正常打印\n\n原理分析Spring Cloud 会在prepareEnvironment时加载一个bootstrap的容器 此容器负责初始化 bootstrap的配置 并且没有Banner，所以在平时我们是感知不到有另一个容器的,此文中不聊相关问题，只讨论如何解决最后输出日志和创建文件是由各个Appender完成的\n\n\n下面看一下源码\npublic void openFile(String file_name) throws IOException &#123;\n    lock.lock();\n    try &#123;\n        File file &#x3D; new File(file_name);\n        boolean result &#x3D; FileUtil.createMissingParentDirectories(file);\n        if (!result) &#123;\n            addError(&quot;Failed to create parent directories for [&quot; + file.getAbsolutePath() + &quot;]&quot;);\n        &#125;\n\n        ResilientFileOutputStream resilientFos &#x3D; new ResilientFileOutputStream(file, append, bufferSize.getSize());\n        resilientFos.setContext(context);\n        setOutputStream(resilientFos);\n    &#125; finally &#123;\n        lock.unlock();\n    &#125;\n&#125;\n不错，创建文件夹的方法是public的,那说明可以继承之后重写第二步，在读完配置之后如果读不到目标配置，则给一个默认配置\n\n\nSpring 容器的声明周期是用几个有序监听器加载的其中第一个就是Bootstrap监听器第5个就是 加载Log组件的监听器这里我们注意第三个  EnvironmentPostProcessorApplicationListener从名字就可以看出是环境加载之后可以做的事情深入看一下\nprivate void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) &#123;\n\t\tConfigurableEnvironment environment &#x3D; event.getEnvironment();\n\t\tSpringApplication application &#x3D; event.getSpringApplication();\n\t\tfor (EnvironmentPostProcessor postProcessor : getEnvironmentPostProcessors(event.getBootstrapContext())) &#123;\n\t\t\tpostProcessor.postProcessEnvironment(environment, application);\n\t\t&#125;\n\t&#125;\n所以这里有两种方法解决\n\n在EnvironmentPostProcessorApplicationListener 中加入一个 EnvironmentPostProcessor判断\n在监听器列表中  在1-5中插入一个监听器，判断环境内容之后插入默认值即可此文采用这种方法\n\n解决方法\n继承RollingFileAppender 重写openFile 方法，此处注意需要置一个空输出流，否则控制台可能要消失，如果是Java11以后的版本 可以直接使用 OutputStream\u0000.nullOutputStream\u0000()方法\npublic class MyFileAppender&lt;E&gt; extends RollingFileAppender&lt;E&gt; &#123;\n\n    private static final String UNDEFINED &#x3D; &quot;IS_UNDEFINED&quot;;\n\n    @Override\n    public void openFile(String fileName) throws IOException &#123;\n        if (fileName.contains(UNDEFINED)) &#123;\n            this.setOutputStream(new NullOutputStream());\n            return;\n        &#125;\n        super.openFile(fileName);\n    &#125;\n\n    public static class NullOutputStream extends OutputStream&#123;\n        private volatile boolean closed;\n\n        private void ensureOpen() throws IOException &#123;\n            if (closed) &#123;\n                throw new IOException(&quot;Stream closed&quot;);\n            &#125;\n        &#125;\n\n        @Override\n        public void write(int b) throws IOException &#123;\n            ensureOpen();\n        &#125;\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException &#123;\n            ensureOpen();\n        &#125;\n\n        @Override\n        public void close() &#123;\n            closed &#x3D; true;\n        &#125;\n    &#125;\n\n&#125;\n\n加入logback配置文件，下面是伪配置文件例子\n&lt;appender name&#x3D;&quot;info&quot; class&#x3D;&quot;org.gongxuanzhang.MyFileAppender&quot;&gt;\n\n加入目标位置监听器,这里注意三件事，1.如果是bootstrap的环境，需要判断跳过。2. 通过Spring Boot SPI机制加入spring 配置 3. 加入的监听器在spring中的位置\npublic class MyFilePath implements ApplicationListener&lt;ApplicationEnvironmentPreparedEvent&gt;,\n        Ordered &#123;\n\n\n    @Override\n    public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) &#123;\n        ConfigurableEnvironment environment &#x3D; event.getEnvironment();\n        if (environment.getPropertySources().contains(&quot;bootstrap&quot;)) &#123;\n            &#x2F;&#x2F; 此时是bootstrap\n            return;\n        &#125;\n        String pathFile &#x3D; environment.getProperty(&quot;pathFile&quot;);\n        if(pathFile &#x3D;&#x3D; null)&#123;\n            pathFile &#x3D; &quot;defaultPathFile&quot;;\n\n        &#125;\n        Map&lt;String,Object&gt; myConfig &#x3D; new HashMap&lt;&gt;();\n        myConfig.put(&quot;path-file&quot;,pathFile);\n        MutablePropertySources propertySources &#x3D; environment.getPropertySources();\n        propertySources.addFirst(new MapPropertySource(&quot;myConfig&quot;,myConfig));\n    &#125;\n\n    @Override\n    public int getOrder() &#123;\n        return Ordered.HIGHEST_PRECEDENCE + 11;\n    &#125;\n\n\n&#125;\n\n在 resources中META-INF文件夹中创建 spring.factories 加入类\norg.springframework.context.ApplicationListener &#x3D; org.gongxuanzhang.MyFilePath\n\n\n\n\n\n\n\n\n\n\n完美收工\n","slug":"LogbackandSpring","date":"2022-11-09T03:41:10.000Z","categories_index":"开发相关","tags_index":"疑难杂症","author_index":"龚宣璋"}]